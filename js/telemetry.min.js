/**
 * Telemetry Web SDK v1.0.0
 * Single-file JavaScript SDK for event tracking.
 * 
 * Usage:
 *   Telemetry.init({ appId: 'your-app-id', apiKey: 'your-api-key' });
 *   Telemetry.track('button_clicked', { button: 'signup' });
 *   Telemetry.identify('user-123', { email: 'user@example.com' });
 */
(function(window) {
  'use strict';

  var VERSION = '1.0.0';
  var STORAGE_PREFIX = 'telemetry_';
  
  // Default configuration
  var defaults = {
    appId: null,
    apiKey: null,
    baseURL: '',
    debug: false,
    flushInterval: 30000,
    maxBatchSize: 20,
    trackPageViews: true,
    trackClicks: false,
    sessionTimeout: 30 * 60 * 1000,
    persistence: 'localStorage'
  };

  var config = {};
  var queue = [];
  var superProperties = {};
  var sessionId = null;
  var userId = null;
  var anonymousId = null;
  var lastActivity = Date.now();
  var flushTimer = null;
  var enabled = true;
  var initialized = false;

  // Utility functions
  function uuid() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
      var r = Math.random() * 16 | 0;
      var v = c === 'x' ? r : (r & 0x3 | 0x8);
      return v.toString(16);
    });
  }

  function log(message, isError) {
    if (!config.debug) return;
    var prefix = isError ? '[Telemetry ERROR]' : '[Telemetry]';
    console[isError ? 'error' : 'log'](prefix, message);
  }

  function getStorage() {
    if (config.persistence === 'none') return null;
    try {
      var storage = config.persistence === 'sessionStorage' ? sessionStorage : localStorage;
      storage.setItem('test', 'test');
      storage.removeItem('test');
      return storage;
    } catch (e) {
      return null;
    }
  }

  function storageGet(key) {
    var storage = getStorage();
    if (!storage) return null;
    try {
      var item = storage.getItem(STORAGE_PREFIX + key);
      return item ? JSON.parse(item) : null;
    } catch (e) {
      return null;
    }
  }

  function storageSet(key, value) {
    var storage = getStorage();
    if (!storage) return;
    try {
      storage.setItem(STORAGE_PREFIX + key, JSON.stringify(value));
    } catch (e) {
      log('Storage error: ' + e.message, true);
    }
  }

  function storageRemove(key) {
    var storage = getStorage();
    if (!storage) return;
    try {
      storage.removeItem(STORAGE_PREFIX + key);
    } catch (e) {}
  }

  function getAnonymousId() {
    var id = storageGet('anonymousId');
    if (!id) {
      id = uuid();
      storageSet('anonymousId', id);
    }
    return id;
  }

  function getDeviceInfo() {
    var nav = window.navigator || {};
    var screen = window.screen || {};
    return {
      os: getOS(),
      browser: getBrowser(),
      screen_width: screen.width,
      screen_height: screen.height,
      viewport_width: window.innerWidth,
      viewport_height: window.innerHeight,
      locale: nav.language || nav.userLanguage,
      timezone: Intl ? Intl.DateTimeFormat().resolvedOptions().timeZone : null,
      user_agent: nav.userAgent,
      referrer: document.referrer || null,
      url: window.location.href,
      path: window.location.pathname,
      host: window.location.host
    };
  }

  function getOS() {
    var ua = navigator.userAgent;
    if (/Windows/.test(ua)) return 'Windows';
    if (/Mac/.test(ua)) return 'macOS';
    if (/Linux/.test(ua)) return 'Linux';
    if (/iPhone|iPad/.test(ua)) return 'iOS';
    if (/Android/.test(ua)) return 'Android';
    return 'Unknown';
  }

  function getBrowser() {
    var ua = navigator.userAgent;
    if (/Chrome/.test(ua) && !/Edg/.test(ua)) return 'Chrome';
    if (/Safari/.test(ua) && !/Chrome/.test(ua)) return 'Safari';
    if (/Firefox/.test(ua)) return 'Firefox';
    if (/Edg/.test(ua)) return 'Edge';
    return 'Unknown';
  }

  function updateSession() {
    var now = Date.now();
    if (now - lastActivity > config.sessionTimeout) {
      sessionId = uuid();
      enqueue('session', 'session_start', {});
    }
    lastActivity = now;
  }

  function buildEvent(type, event, properties) {
    updateSession();
    
    var eventData = {
      type: type,
      event: event,
      timestamp: new Date().toISOString(),
      app_id: config.appId,
      session_id: sessionId,
      anonymous_id: anonymousId,
      device: getDeviceInfo(),
      sdk: {
        name: 'telemetry-web',
        version: VERSION
      }
    };

    if (userId) {
      eventData.user_id = userId;
    }

    // Merge super properties with event properties
    var mergedProps = {};
    for (var key in superProperties) {
      mergedProps[key] = superProperties[key];
    }
    if (properties) {
      for (var k in properties) {
        mergedProps[k] = properties[k];
      }
    }
    if (Object.keys(mergedProps).length > 0) {
      eventData.properties = mergedProps;
    }

    return eventData;
  }

  function enqueue(type, event, properties, callback) {
    if (!enabled || !initialized) {
      if (callback) callback();
      return;
    }

    var eventData = buildEvent(type, event, properties);
    queue.push(eventData);
    persistQueue();
    log('Event queued: ' + event);

    if (queue.length >= config.maxBatchSize) {
      flush(callback);
    } else if (callback) {
      callback();
    }
  }

  function persistQueue() {
    storageSet('queue', queue);
  }

  function loadQueue() {
    var saved = storageGet('queue');
    if (saved && Array.isArray(saved)) {
      queue = saved;
    }
  }

  function flush(callback) {
    if (queue.length === 0) {
      if (callback) callback();
      return;
    }

    var events = queue.slice();
    queue = [];
    persistQueue();

    log('Flushing ' + events.length + ' events');

    var payload = {
      batch: events,
      sent_at: new Date().toISOString()
    };

    var xhr = new XMLHttpRequest();
    xhr.open('POST', config.baseURL + '/api/ingest', true);
    xhr.setRequestHeader('Content-Type', 'application/json');
    xhr.setRequestHeader('Authorization', 'Bearer ' + config.apiKey);
    xhr.setRequestHeader('X-App-Id', config.appId);

    xhr.onreadystatechange = function() {
      if (xhr.readyState === 4) {
        if (xhr.status >= 200 && xhr.status < 300) {
          log('Flush successful');
        } else {
          log('Flush failed: ' + xhr.status, true);
          // Re-queue events on failure
          queue = events.concat(queue);
          persistQueue();
        }
        if (callback) callback();
      }
    };

    xhr.onerror = function() {
      log('Flush network error', true);
      queue = events.concat(queue);
      persistQueue();
      if (callback) callback();
    };

    try {
      xhr.send(JSON.stringify(payload));
    } catch (e) {
      log('Flush error: ' + e.message, true);
      queue = events.concat(queue);
      persistQueue();
      if (callback) callback();
    }
  }

  function setupAutoTracking() {
    // Auto page view tracking
    if (config.trackPageViews) {
      // Track initial page view
      Telemetry.page();

      // Track history changes (SPA support)
      var pushState = history.pushState;
      history.pushState = function() {
        pushState.apply(history, arguments);
        Telemetry.page();
      };

      window.addEventListener('popstate', function() {
        Telemetry.page();
      });
    }

    // Auto click tracking
    if (config.trackClicks) {
      document.addEventListener('click', function(e) {
        var target = e.target;
        while (target && target.tagName !== 'A') {
          target = target.parentElement;
        }
        if (target && target.tagName === 'A') {
          Telemetry.track('link_clicked', {
            url: target.href,
            text: target.innerText.substring(0, 100)
          });
        }
      }, true);
    }

    // Flush on page unload
    window.addEventListener('beforeunload', function() {
      flush();
    });

    // Flush on visibility change
    document.addEventListener('visibilitychange', function() {
      if (document.visibilityState === 'hidden') {
        flush();
      }
    });
  }

  // Public API
  var Telemetry = {
    init: function(options) {
      if (!options || !options.appId || !options.apiKey) {
        console.error('[Telemetry] appId and apiKey are required');
        return;
      }

      // Merge config
      config = {};
      for (var key in defaults) {
        config[key] = options.hasOwnProperty(key) ? options[key] : defaults[key];
      }
      config.appId = options.appId;
      config.apiKey = options.apiKey;

      // Initialize state
      anonymousId = getAnonymousId();
      sessionId = uuid();
      userId = storageGet('userId');
      superProperties = storageGet('superProperties') || {};
      loadQueue();

      initialized = true;
      log('Initialized for app: ' + config.appId);

      // Start flush timer
      if (flushTimer) clearInterval(flushTimer);
      flushTimer = setInterval(flush, config.flushInterval);

      // Track session start
      enqueue('session', 'session_start', {});

      // Setup auto tracking
      setupAutoTracking();
    },

    track: function(event, properties, callback) {
      if (typeof properties === 'function') {
        callback = properties;
        properties = null;
      }
      enqueue('track', event, properties, callback);
    },

    page: function(name, properties, callback) {
      if (typeof name === 'object') {
        callback = properties;
        properties = name;
        name = null;
      }
      if (typeof properties === 'function') {
        callback = properties;
        properties = null;
      }

      var props = properties || {};
      props.page_name = name || document.title;
      props.url = window.location.href;
      props.path = window.location.pathname;
      props.referrer = document.referrer;
      props.title = document.title;

      enqueue('screen', 'page_view', props, callback);
    },

    identify: function(id, traits, callback) {
      if (typeof traits === 'function') {
        callback = traits;
        traits = null;
      }

      userId = id;
      storageSet('userId', id);

      var props = traits || {};
      props.user_id = id;

      enqueue('identify', 'identify', props, callback);
    },

    reset: function() {
      userId = null;
      storageRemove('userId');
      anonymousId = uuid();
      storageSet('anonymousId', anonymousId);
      sessionId = uuid();
      log('User reset');
    },

    trackConversion: function(type, options, callback) {
      if (typeof options === 'function') {
        callback = options;
        options = {};
      }
      options = options || {};

      var props = options.properties || {};
      props.conversion_type = type;
      if (options.productId) props.product_id = options.productId;
      if (options.revenue !== undefined) {
        props.revenue = options.revenue;
        props.currency = options.currency || 'USD';
      }

      enqueue('conversion', 'conversion', props, callback);
    },

    trackTrialStarted: function(productId, properties, callback) {
      this.trackConversion('trial_started', {
        productId: productId,
        properties: properties
      }, callback);
    },

    trackPurchase: function(options, callback) {
      this.trackConversion('purchase', options, callback);
    },

    setSuperProperty: function(key, value) {
      superProperties[key] = value;
      storageSet('superProperties', superProperties);
    },

    setSuperProperties: function(props) {
      for (var key in props) {
        superProperties[key] = props[key];
      }
      storageSet('superProperties', superProperties);
    },

    removeSuperProperty: function(key) {
      delete superProperties[key];
      storageSet('superProperties', superProperties);
    },

    clearSuperProperties: function() {
      superProperties = {};
      storageSet('superProperties', superProperties);
    },

    flush: function(callback) {
      flush(callback);
    },

    enable: function() {
      enabled = true;
      log('Tracking enabled');
    },

    disable: function() {
      enabled = false;
      log('Tracking disabled');
    },

    isEnabled: function() {
      return enabled;
    },

    debug: function(enable) {
      config.debug = enable;
    },

    getQueue: function() {
      return queue.slice();
    },

    clearStorage: function() {
      var storage = getStorage();
      if (!storage) return;
      var keys = [];
      for (var i = 0; i < storage.length; i++) {
        var key = storage.key(i);
        if (key && key.indexOf(STORAGE_PREFIX) === 0) {
          keys.push(key);
        }
      }
      keys.forEach(function(key) {
        storage.removeItem(key);
      });
      queue = [];
      superProperties = {};
      userId = null;
      anonymousId = uuid();
      log('Storage cleared');
    },

    version: VERSION
  };

  // Export
  if (typeof module !== 'undefined' && module.exports) {
    module.exports = Telemetry;
  } else {
    window.Telemetry = Telemetry;
  }

})(typeof window !== 'undefined' ? window : this);
